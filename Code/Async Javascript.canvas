{
	"nodes":[
		{"id":"9d68098a321081a0","type":"text","text":"# Synchronous and Asynchronous\n\nJavascript by nature is a synchronous language, meaning it is single threaded. In essence, it runs the code line by line and doesn't move to the next line until the previous line is completed executing.\n\nAsynchronous javascript allows us to build functions that *start now and finish later* while the code continues further, basically multi threading.","x":-620,"y":-223,"width":680,"height":243},
		{"id":"64abb61177147994","type":"text","text":"# HTTP Requests\nHTTP Requests help us get data from another server.\nWe make these requests to API endpoints.","x":100,"y":-223,"width":480,"height":157},
		{"id":"ba72673ef21c9aef","type":"text","text":"# Internal HTTP Requests\nWhile HTTP requests are primarily used to communicate with external servers, they can indeed be used to interact with your own server as well. This is often referred to as making an internal HTTP request.\n#### Why would you do this?\nModularity: Breaking down your application into smaller, independent services that communicate via HTTP can improve code organization and maintainability.\nStandardization: Using a standard protocol like HTTP ensures consistent communication between different parts of your application.\nSecurity: HTTP requests can be secured using mechanisms like authentication and authorization to protect sensitive data.\nTesting: You can easily test individual components of your application by making HTTP requests to them.\nHow to Access Data on Your Own Server:\n#### Direct File Access:\nIf you're working within the same application or server environment, you can often access files directly using file system paths or built-in functions provided by your programming language or framework.\nInternal HTTP Requests:\n\n#### Using a Library:\nMost programming languages have libraries or frameworks that can make HTTP requests. For example:\n- In Python, you can use requests or the built-in `urllib` library.\n- In JavaScript, you can use fetch or the `axios` library.\nSetting Up a Web Server: If your data is structured as a web resource (e.g., a JSON API), you can set up a web server (like a Node.js server or a Python Flask app) to serve that data. Then, you can make HTTP requests to the appropriate endpoints on that server.\nExample:\n\nLet's say you have a Node.js application with a JSON file containing user data:\n```JavaScript\n// user_data.json\n[\n  { \"id\": 1, \"name\": \"Alice\" },\n  { \"id\": 2, \"name\": \"Bob\" }\n]\nUse code with caution.\n\nYou can create a simple Node.js server to serve this data:\n\nJavaScript\nconst express = require('express');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\napp.get('/users', (req, res) => {\n  fs.readFile('user_data.json', 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading file');\n    } else {\n      res.json(JSON.parse(data));\n    }\n  });\n});\n\napp.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});\n```\n\nNow, you can make an HTTP request to *http://localhost:3000/users* from within your Node.js application to fetch the user data.\n\nRemember: While making internal HTTP requests can be a powerful technique, it's important to balance the benefits with the potential overhead and complexity. In many cases, direct file access or other simpler methods might be more appropriate.\n\nDo you have any specific programming language or framework in mind? I can provide more tailored examples.","x":100,"y":-40,"width":480,"height":600},
		{"id":"cd2ed6adf1cd7614","type":"text","text":"# XMLHttpRequest\n\nBefore JSON, data files were exchanged through the net via file type called XML. But JSON later replaced XML. We used XMLHttpRequest object to request XML files via the internet using Javascript. But after the introduction of JSON, XMLHttpRequest object was modified to be able to deliver all kinds of file types.\n\n`const request = new XMLHttpRequest();`\n\nThe request object has several properties and methods. One of them being `request.readyState` which shows the current state of the request.\n![[Pasted image 20241102143328.png]]\n\n```javascript\nrequest.onreadystatechange = () => {\n    if(request.readyState==4) {\n        console.log(JSON.parse(request.response));\n    }\n}\nrequest.open(\"GET\", \"https://api.github.com/users/MeetCoding\");\nrequest.send();\n```\n\nBy default, the response we get is in string format, so we can parse it using the `JSON.parse()` method to convert it into javascript object.\n\nFor XML data, we use:\n```javascript\nconst xmlString = `<note> \n\t\t<to>Tove</to> \n\t\t<from>Jani</from> \n\t\t<heading>Reminder</heading> \n\t\t<body>Don't forget me this weekend!</body> \n\t\t</note>`;\nconst parser = new DOMParser();\nconst xmlDoc = parser.parseFromString(request.response, 'text/xml');\n\t// Converting into HTML\nconst rootElement = xmlDoc.documentElement;\n```\n\nThe request objects has several event listeners like:\n1. `onreadystatechange`\n2. `onerror`\n3. `onload`\n4. `onloadstart`\n5. `onprogress`\n6. `ontimeout`\nWe can access the data using the `request.response` property and url can also be accessed using `request.responseURL`\nYou can also alternatively use the `addEventListener` property\n```javascript\nrequest.addEventListener(\"readystatechange\", () => {\n\tif(request.readyState==4) {\n\t\tcosnole.log(JSON.parse(request.response));\n\t}\n})\n```\n\nYou can check the status of the request by using `request.status`\n\n| **Status** | **Meaning**             |\n| ---------- | ----------------------- |\n| 100-199    | Informational responses |\n| 200-299    | Successful responses    |\n| 300-399    | Redirection message     |\n| 400-499    | Client error response   |\n| 500-599    | Server error response   |\n","x":-620,"y":40,"width":680,"height":520},
		{"id":"a904215e77b1c68d","x":600,"y":-223,"width":600,"height":783,"type":"text","text":"# Promises\n\n```javascript\nlet promise = new Promise((resolve, reject) => {\n\tlet data = getData();\n\tif(data) {\n\t\tresolve(data)\n\t} else {\n\t\treject(\"Data not found\")\n\t}\n})\n\npromise.then(data => {\n\tconsole.log(\"Data received: \", data);\n}).catch(err => {\n\tconsole.log(err)\n})\n```\n\nPromise constructor takes in a callback function as an argument. The function will immediately be called by the promise object and it will pass it two functions, resolve and reject as an argument which we can use.\n\nWhen we call resolve function, the argument of `promise.then()` is run and if we reject the promise, then the `promise.catch()` is called.\n\nWe can also use functions like `Promise.all()` and `Promise.race()`.\n```javascript\nPromise.all([promise1, promise2, promise3]).then(msgs => {\n\tconsole.log(\"all promises resolved\");\n})\nPromise.race([promise1, promise2, promise3]).then(msg => {\n\tconsole.log(\"any one promise resolved\");\n})\n```"},
		{"id":"200273765203df56","x":1220,"y":-223,"width":580,"height":783,"type":"text","text":"# Fetch API\nFetch API is a more simple and modern approach to make HTTP calls internally or externally. The fetch function is in-built and returns a promise.\n```javascript\nfetch(\"url\").then(response => {\n\tconsole.log(\"resolved with status: \", response.status);\n}).catch(err => {\n\tconsole.log(\"Error, offline\");\n})\n```\nNote that fetch will reject the promise only if you are offline or the server is not reachable. In other all cases, it will be resolved even if you get a 404 error. So you'll have to check for status code in the `then` function.\n\nTo get the data, we use the `response.json()` method which further returns us a promise which is resolved if the data is parsed correctly as json.\n```javascript\nfetch(\"url\").then(response => {\n\tconsole.log(\"resolved with status: \", response.status);\n\tlet data = response.json()\n\tdata.then(data => {\n\t\tconsole.log(data)\n\t}).catch(err => {\n\t\tconsole.log(\"Not JSON\")\n\t})\n}).catch(err => {\n\tconsole.log(\"Error, offline\");\n})\n```"},
		{"id":"2b2d49561bd41f9c","x":1820,"y":-223,"width":480,"height":603,"type":"text","text":"# Async and Await\nAn asynchronous function always returns a promise.\n```javascript\nlet getData = async () => {\n\treturn \"data\";\n}\ngetData().then(data => console.log(data));\n```\nThis can simplify chaining promises together:\n```javascript\nlet getData = async () => {\n\tlet response = await fetch(\"url\")\n\tif(response.status !== 200) {\n\t\tthrow new Error(\"Couldn't fetch\")\n\t}\n\tlet data = await response.json()\n\treturn data\n}\ngetData()\n\t.then(data => console.log(data))\n\t.catch(err => console.log(err))\n```"}
	],
	"edges":[]
}